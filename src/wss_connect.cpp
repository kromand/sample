/*
 * wss_connect.cpp
 *
 *  Created on: Jun 25, 2017
 *      Author: kris
 */

#include "wss_connect.hpp"


    void check_type( const msgpack::object& obj, int identSize=0)
    {

        std::string ident = "";
        for(int i=1;i<=identSize; i++)
            ident += " ";

        if( obj.type == msgpack::type::ARRAY)
            std::cout << ident << "ARRAY" << std::endl;
        else if( obj.type == msgpack::type::NIL)
            std::cout << ident << "NIL" << std::endl;
        else if( obj.type == msgpack::type::BOOLEAN)
            std::cout << ident << "BOOLEAN" << std::endl;
        else if( obj.type == msgpack::type::POSITIVE_INTEGER)
            std::cout << ident << "POSITIVE_INTEGER" << std::endl;
        else if( obj.type == msgpack::type::NEGATIVE_INTEGER)
            std::cout << ident << "NEGATIVE_INTEGER" << std::endl;
        else if( obj.type == msgpack::type::STR)
        {
            std::string v = obj.as<std::string>();
            std::cout << ident << "STR: "<< v << std::endl;
        }
        else if( obj.type == msgpack::type::BIN)
            std::cout << ident << "BIN" << std::endl;
        else if( obj.type == msgpack::type::EXT)
            std::cout << ident << "EXT" << std::endl;
        else if( obj.type == msgpack::type::MAP)
        {
            std::cout << ident << "MAP size:" << obj.via.map.size << std::endl;
            for(unsigned int i = 0; i< obj.via.map.size; i++)
            {
                std::cout << ident+" " << "Key:" << i << std::endl;
                check_type(obj.via.map.ptr[i].key, identSize+2);
                std::cout << ident+" " << "Value:" << i << std::endl;
                check_type(obj.via.map.ptr[i].val, identSize+2);
            }

        }
        else
            std::cout<< "Udefined" << std::endl;
    }

void wss_connection::rx_handler(const autobahn::wamp_event& event)
{
	std::cout<<"ARGS : "<<event.number_of_arguments()<<endl;
	try
	{
		string  seq{"seq"};
		msgpack::object arg = event.kw_argument<msgpack::object>(seq);
		std::cout<<"Sequence: "<<arg.via.map.size<<endl;
	}
	catch(const std::exception& e)
	{
		std::cerr <<"Kw argument exception: "<< e.what() << std::endl;
	}
	for( unsigned int i = 0; i< event.number_of_arguments(); i++)
	{
		try {
			msgpack::object argument = event.argument<msgpack::object>(i);
			check_type(argument);
		}
		catch(const std::exception& e)
		{
			std::cerr <<"Exc: "<< e.what() << std::endl;
		}
	}
}
//RX message: event [6087553355470234, 8698444017817420, {}, ["XMR_DASH", "4.73321181", "4.76594218", "4.71092410", "0.16779632", "1144.08212599", "262.86826163", 0, "4.78092041", "3.99883397"]]
//JSON parser exception: <unspecified file>(1): expected value
void wss_connection::wss_start()
{
	connect();
}
void wss_connection::connect()
{
	if(state == ConnectionState::Disconnected) state = ConnectionState::InProgress;
	else return;
	pt::ptree root;
	root.put("type", "subscribe");
	std::cout << "Using Boost "
	          << BOOST_VERSION / 100000     << "."  // major version
	          << BOOST_VERSION / 100 % 1000 << "."  // minor version
	          << BOOST_VERSION % 100                // patch level
	          << std::endl;

    try {

        if(debugModeOn) cout << "Connecting... "<< std::endl;

        boost::asio::io_service io;
        client ws_client;
        ws_client.init_asio(&io);
        ws_client.set_tls_init_handler([&](websocketpp::connection_hdl) {
            return websocketpp::lib::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::tlsv12_client);
        });
        auto transport = std::make_shared < autobahn::wamp_websocketpp_websocket_transport<websocketpp::config::asio_tls_client> >(
                ws_client, "wss://api.poloniex.com:443", false);
        //wss://ws-feed.gdax.com
        // create a WAMP session that talks WAMP-RawSocket over TCP
        //
        auto session = std::make_shared<autobahn::wamp_session>(io, true);

        transport->attach(std::static_pointer_cast<autobahn::wamp_transport_handler>(session));

        // Make sure the continuation futures we use do not run out of scope prematurely.
        // Since we are only using one thread here this can cause the io service to block
        // as a future generated by a continuation will block waiting for its promise to be
        // fulfilled when it goes out of scope. This would prevent the session from receiving
        // responses from the router.
        boost::future<void> connect_future;
        boost::future<void> start_future;
        boost::future<void> join_future;
        boost::future<void> subscribe_future;
        connect_future = transport->connect().then([&](boost::future<void> connected) {
            try {
                connected.get();
            } catch (const std::exception& e) {
                std::cerr <<"Connection exception: "<< e.what() << std::endl;
                io.stop();
                state = ConnectionState::Disconnected;
                return;
            }

            if(debugModeOn) cout << "Transport connected." << std::endl;

            start_future = session->start().then([&](boost::future<void> started) {
                try {
                    started.get();
                } catch (const std::exception& e) {
                    std::cerr <<"Session start exception: "<< e.what() << std::endl;
                    io.stop();
                    state = ConnectionState::Disconnected;
                    return;
                }

                if(debugModeOn) cout << "Session started." << std::endl;
                join_future = session->join("realm1").then([&](boost::future<uint64_t> joined) {
                    try {
                    	if(debugModeOn) cout << "Joined realm: " << joined.get() << std::endl;
                    } catch (const std::exception& e) {
                        std::cerr <<"Session join exception: "<< e.what() << std::endl;
                        io.stop();
                        state = ConnectionState::Disconnected;
                        return;
                    }
                    state = ConnectionState::Connected;
                    subscribe_future = session->subscribe("BTC_ETH", &rx_handler).then([&] (boost::future<autobahn::wamp_subscription> subscribed)
                    {
                        try {

                        	if(debugModeOn) cout << "subscribed to topic: " << subscribed.get().id() << std::endl;
                        }
                        catch (const std::exception& e) {
                            std::cerr <<"Subscribe exception: "<< e.what() << std::endl;
                            io.stop();
                            state = ConnectionState::Disconnected;
                            return;
                        }

                    });


                });
            });
        });

        if(debugModeOn) cout << "Starting io service" << std::endl;
        io.run();

        if(debugModeOn) cout << "Stopped io service" << std::endl;
    }
    catch (std::exception& e) {
        std::cerr << "exception: " << e.what() << std::endl;
        state = ConnectionState::Disconnected;
        return;
    }
}

